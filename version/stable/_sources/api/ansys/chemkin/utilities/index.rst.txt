





The ``ansys.chemkin.utilities`` library
=======================================

.. py:module:: ansys.chemkin.utilities


Summary
-------








.. py:currentmodule:: utilities
.. tab-set::







    .. tab-item:: Functions

        .. list-table::
          :header-rows: 0
          :widths: auto


          * - :py:obj:`~where_element_in_array_1D`
            - Find the number of occurrence and the element index in the 1D arr array that matches the target value.


          * - :py:obj:`~bisect`
            - Use bisectional method to find the largest index in the xarray of which its value is small or equal to the target x value


          * - :py:obj:`~find_interpolate_parameters`
            - Find the index ileft that


          * - :py:obj:`~interpolate_array`
            - Find the value in the y_array from the interpolation parameters ileft and ratio


          * - :py:obj:`~create_mixture_recipe_from_fractions`
            - Build a PyChemkin mixture recipe/formula from a species fraction array (i.e., mixture mole/mass composition).


          * - :py:obj:`~calculate_stoichiometrics`
            - calculate the stoichiometric coefficients of the complete combustion reaction of the given fuel and oxidizer mixtures.


          * - :py:obj:`~random`
            - Generate a (reproducible) random floating number value >= 0.0 and < 1.0


          * - :py:obj:`~find_file`
            - Find the correct version of the given partial file name.



    .. tab-item:: Attributes

        .. list-table::
          :header-rows: 0
          :widths: auto


          * - :py:obj:`~ck_rng`
            - 
















Description
-----------

pychemkin utilities







Module detail
-------------

.. py:function:: where_element_in_array_1D(arr: Union[numpy.typing.NDArray[numpy.double], numpy.typing.NDArray[numpy.int32]], target: Union[int, float]) -> tuple[int, numpy.typing.NDArray[numpy.int32]]

   Find the number of occurrence and the element index in the 1D arr array that matches the target value.
   Using numpy.argwhere might be more efficient. However, the numpy method returns a list of lists of occurrence indices
   while this might be necessary for general applications, it is an overkill for simple 1D array cases.

   Parameters
   ----------
       arr: integer or double array
           the reference 1D integer or double array
       target: integer or double scalar
           the target value to be matched

   Returns
   -------
       number_of_occurrences: integer
       occurrence_index: integer array


.. py:function:: bisect(ileft: int, iright: int, x: float, xarray) -> int

   Use bisectional method to find the largest index in the xarray of which its value is small or equal to the target x value

   Parameters
   ----------
       ileft: integer
           index of xarray that represents the current lower bound
       iright: integer
           index of xarray that represents the current upper bound
       x: double
           target value
       xarray: double array
           a sorted array containing all x values in strictly ascending order x[i] < x[i+1]

   Returns
   -------
       itarget: integer
           the largest index in the xarray of which its value is small or equal to the target x value


.. py:function:: find_interpolate_parameters(x: float, xarray: numpy.typing.NDArray[numpy.double]) -> tuple[int, float]

   Find the index ileft that
      xarray[ileft] <= x <= xarray[iright] where iright = ileft + 1

   Parameters
   ----------
       x: double
           target value
       xarray: double array
           a sorted array containing all x values in strictly ascending order x[i] < x[i+1]

   Returns
   -------
   itarget: integer
       the largest index in the xarray of which its value is small or equal to the target x value
   ratio: double
       the distance ratio = (x - xarray[ileft])/(xarray[ileft+1] - xarray[ileft])


.. py:function:: interpolate_array(x: float, x_array: numpy.typing.NDArray[numpy.double], y_array: numpy.typing.NDArray[numpy.double]) -> float

   Find the value in the y_array from the interpolation parameters ileft and ratio
       y = (1-ratio)* y_array[ileft] + ratio * y_array[ileft+1]
       where ileft and ratio are determined from the target x value and the xarray

   Parameters
   ----------
       x: double
           target value
       x_array: double array
           a sorted array containing all x values in strictly ascending order x[i] < x[i+1]
       y_array: double array
           dependent variable array

   Returns
   -------
       y: double
           the interpolated dependent variable value corresponding the given x value


.. py:function:: create_mixture_recipe_from_fractions(chemistry_set: ansys.chemkin.chemistry.Chemistry, frac: numpy.typing.NDArray[numpy.double]) -> tuple[int, list[tuple[str, float]]]

   Build a PyChemkin mixture recipe/formula from a species fraction array (i.e., mixture mole/mass composition).
   This mixture recipe can then be used to create the corresponding Mixture object.

   Parameters
   ----------
   chemistry_set: Chemistry object
       the Chemistry object will be used to create the mixture
   frac: double array
       mole or mass fractions of the mixture

   Returns
   -------
       count: integer
           the size of the recipe list containing [gas species, mole/mass fraction] tuples
       recipe: list of tuples, [(species_symbol, fraction), ... ]
           non-zero mixture composition corresponding to the given mole/mass fraction array


.. py:function:: calculate_stoichiometrics(chemistryset: ansys.chemkin.chemistry.Chemistry, fuel_molefrac: numpy.typing.NDArray[numpy.double], oxid_molefrac: numpy.typing.NDArray[numpy.double], prod_index: numpy.typing.NDArray[numpy.int32]) -> tuple[float, numpy.typing.NDArray[numpy.double]]

   calculate the stoichiometric coefficients of the complete combustion reaction of the given fuel and oxidizer mixtures.
   Consider the complete combustion of the fuel + oxidizer mixture
   ::
       (fuel species) + alpha*(oxidizer species) <=> nu(1)*prod(1) + ... + nu(numb_prod)*prod(numb_prod)

   The number of unknowns is equal to the number of elements that make of all the fuel and oxidizer species. And the
   number of product species must be one less than the number of unknowns.
   The unknowns
   ::
       alpha is the stoichiometric coefficient multiplier of the oxidizer species
       nu(1), ... nu(numb_prod) are the stoichiometric coefficients of the product species

   The conservation of elements yields a set of linear algebraic equations
   ::
       A x = b
   in which x = [ -alpha | nu(1), ...., nu(numb_prod) ]  (a vector of size numb_elem ) can be obtained.

   Parameters
   ----------
       chemistryset: Chemistry object
           the Chemistry object used to create the fuel and the oxidizer mixtures
       fuel_molefrac: 1-D double array
           mole fractions of the fuel mixture
       oxid_molefrac: 1-D double array
           mole fractions of the oxidizer mixture
       prod_index: 1-D integer array
           the species indices of the complete combustion products

   Returns
   -------
       alpha: double
           oxidizer_coefficient_multiplier
       nu: 1-D double array
           stoichiometric_coefficients_of_products


.. py:function:: random(range: Union[None, tuple[float, float]] = None) -> float

   Generate a (reproducible) random floating number value >= 0.0 and < 1.0
   by using the Numpy pseudo-random number generator.
   If the range tuple (a, b) is given, the random number will
   have a value >= a and < b.

   Parameters
   ----------
       range: tuple of floats (a, b) and b > a, default = (0.0, 1.0)
           the range of the random number values

   Returns
   -------
       random: float
           random number


.. py:function:: find_file(filepath: str, partialfilename: str, fileext: str) -> str

   Find the correct version of the given partial file name.
   This is mostly to handle the different years/versions of the
   MFL mechanisms that come with the Ansys Chemkin installation.

   Parameters
   ----------
       filepath: string
           the directory where the file is located
       partialfilename: string
           the leading portion of the file name
       fileext: string
           file extension

   Returns
   -------
       thefile: string
           full path name of the file, = "" if no file matches the 'partialname' in the 'filepath'


.. py:data:: ck_rng
   :value: None




